/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
nums=[0,1,1,3,3]
k=4
var findMaxAverage = function(nums, k) {
    //find subarray with k length and max avg value. Return the value
    //value can be negative
    // we can loop and compare all possible combination. This is time complexity one. 
    //we can have pointer 1 at index 0 and pointer 2 at index 1, consider add next number and add if sum goes up.. but avg sum doesnt guarantee going up always. 
    //I can have sum of everything and choose if I remove 1 on the left, what is the avg, remove oen to the right what is the avg

    let left=0
    let right=k
    let max_sum= nums.slice(left,right).reduce((a,b)=>a+b,0)
    console.log("initial max sum",max_sum)
    let current_sum = max_sum
    while(right<nums.length){
        
         current_sum =  current_sum- nums[left] + nums[right]
        console.log("current sum",current_sum, "nums[left]",nums[left],"nums[right]",nums[right])
        if(current_sum>max_sum){
            max_sum=current_sum
        }
        left++
        right++
        
    }
    return max_sum/k
};

console.log(findMaxAverage(nums,k))